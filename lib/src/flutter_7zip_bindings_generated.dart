// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/flutter_7zip.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class Flutter7zipBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Flutter7zipBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Flutter7zipBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  void freeArchiveFile(
    ArchiveFile archive,
  ) {
    return _freeArchiveFile(
      archive,
    );
  }

  late final _freeArchiveFilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ArchiveFile)>>(
          'freeArchiveFile');
  late final _freeArchiveFile =
      _freeArchiveFilePtr.asFunction<void Function(ArchiveFile)>();

  ffi.Pointer<ffi.Void> openArchive(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _openArchive(
      path,
    );
  }

  late final _openArchivePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>)>>('openArchive');
  late final _openArchive = _openArchivePtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>();

  ArchiveStatus checkArchiveStatus(
    ffi.Pointer<ffi.Void> archive,
  ) {
    return ArchiveStatus.fromValue(_checkArchiveStatus(
      archive,
    ));
  }

  late final _checkArchiveStatusPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ffi.Void>)>>(
      'checkArchiveStatus');
  late final _checkArchiveStatus =
      _checkArchiveStatusPtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  void closeArchive(
    ffi.Pointer<ffi.Void> archive,
  ) {
    return _closeArchive(
      archive,
    );
  }

  late final _closeArchivePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'closeArchive');
  late final _closeArchive =
      _closeArchivePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  int getArchiveFileCount(
    ffi.Pointer<ffi.Void> archive,
  ) {
    return _getArchiveFileCount(
      archive,
    );
  }

  late final _getArchiveFileCountPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<ffi.Void>)>>(
          'getArchiveFileCount');
  late final _getArchiveFileCount =
      _getArchiveFileCountPtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  ArchiveFile getArchiveFile(
    ffi.Pointer<ffi.Void> archive,
    int index,
  ) {
    return _getArchiveFile(
      archive,
      index,
    );
  }

  late final _getArchiveFilePtr = _lookup<
      ffi.NativeFunction<
          ArchiveFile Function(
              ffi.Pointer<ffi.Void>, ffi.Uint32)>>('getArchiveFile');
  late final _getArchiveFile = _getArchiveFilePtr
      .asFunction<ArchiveFile Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.UnsignedChar> readArchiveFile(
    ffi.Pointer<ffi.Void> archive,
    int index,
  ) {
    return _readArchiveFile(
      archive,
      index,
    );
  }

  late final _readArchiveFilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              ffi.Pointer<ffi.Void>, ffi.Uint32)>>('readArchiveFile');
  late final _readArchiveFile = _readArchiveFilePtr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<ffi.Void>, int)>();

  void freeReadData(
    ffi.Pointer<ffi.Void> p,
  ) {
    return _freeReadData(
      p,
    );
  }

  late final _freeReadDataPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'freeReadData');
  late final _freeReadData =
      _freeReadDataPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ArchiveStatus extractArchiveToFile(
    ffi.Pointer<ffi.Void> archive,
    int index,
    ffi.Pointer<ffi.Char> path,
  ) {
    return ArchiveStatus.fromValue(_extractArchiveToFile(
      archive,
      index,
      path,
    ));
  }

  late final _extractArchiveToFilePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<ffi.Void>, ffi.Uint32,
              ffi.Pointer<ffi.Char>)>>('extractArchiveToFile');
  late final _extractArchiveToFile = _extractArchiveToFilePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>)>();
}

final class ArchiveFile extends ffi.Struct {
  /// utf-16
  external ffi.Pointer<ffi.Uint16> name;

  @ffi.Size()
  external int size;

  @ffi.Int()
  external int is_dir;

  @ffi.Uint32()
  external int crc32;

  /// create
  @ffi.Uint64()
  external int cTime;

  /// modify
  @ffi.Uint64()
  external int mTime;
}

enum ArchiveStatus {
  kArchiveOK(0),
  kArchiveError(1),
  kArchiveOpenError(2),
  kArchiveReadError(3),
  kArchiveWriteError(4),
  kArchiveSeekError(5);

  final int value;
  const ArchiveStatus(this.value);

  static ArchiveStatus fromValue(int value) => switch (value) {
        0 => kArchiveOK,
        1 => kArchiveError,
        2 => kArchiveOpenError,
        3 => kArchiveReadError,
        4 => kArchiveWriteError,
        5 => kArchiveSeekError,
        _ => throw ArgumentError("Unknown value for ArchiveStatus: $value"),
      };
}
